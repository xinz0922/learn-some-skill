# python三大库

## numpy（numeric Python）——Python的科学计算库

如果没有numpy库可以用pip进行安装

`pip install numpy`

### numpy的一些属性

|属性|功能|
|:-:|:-:|
|numpy.array|创建矩阵|
|shape|以元组数据展示矩阵的维度及各维度的元素个数|
|ndim|矩阵的维度|
|size|矩阵的元素总数|
|dtype|矩阵的元素格式|

### 创建矩阵

|zeros|创建元素全部为0的矩阵，参数可设置行、列的数目|
|:-:|:-:|
|ones|创建元素全部为0的矩阵，参数可设置行、列的数目|
|empty|生成无线接近0但非0的数，可以除以该数，得到的商是个非常非常大的数|
|arange|设置参数使得生成一维矩阵，和range函数一样的用法|
|reshape|将元素分为几行几列的|


**注:arange和reshape可以连用**

`a = numpy.arange(10).reshape(2,5)` #得到2行5列的元素为0-9的矩阵

### numpy的运算

举例说明
```
$ import numpy as np

$ arr1 = np.array([[1,2,3],[4,5,6]])

$ arr2 = np.array([[1,1,2],[2,2,3]])
```
- 相加：`$ arr1 + arr2`
- 相减：`$ arr1 - arr2`
- 相乘：`$ arr1 * arr2`
- 相除：`$ arr1 / arr2  # 这样是商只取整数部分，如果想得到浮点数类型的商，需要设置矩阵的类型，只设置一个都可以，例如arr2 = np.array([[1,1,2],[2,2,3]]，dtype = float)`
- 取整：`$ arr1 // arr2  #取整和int类型的数字相除的结果一样`
- 取余：`$ arr1 % arr2`
- 幂运算：`$ arr1 ** arr2`
- **矩阵乘法**：
   ```$ a = np.arange(10).reshape(2,5)
   $ a 
   array([[0, 1, 2, 3, 4],
       [5, 6, 7, 8, 9]])
   $ b = numpy.arange(15).reshape(5,3)
   $ b
   array([[ 0,  1,  2],
       [ 3,  4,  5],
       [ 6,  7,  8],
       [ 9, 10, 11],
       [12, 13, 14]])
   * $ **np.dot(a,b)**
   array([[ 90, 100, 110],
       [240, 275, 310]])
   * $ a.dot(b)   # 两种用法意义相同
   ```
- 转置矩阵
```np.transpose(arr1) == arr1.T  #  两者用法相同
> $ arr1
> array([[0, 1, 2, 3, 4],
       [5, 6, 7, 8, 9]])
> $ arr1.T
> array([[0, 5],
       [1, 6],
       [2, 7],
       [3, 8],
       [4, 9]])
       
```
### 随机数生成及矩阵的运算
- 生成随机数矩阵
```> import numpy as np
a = np.random.random((2,3))   # 生成2行3列随机数矩阵，主需要一个参数，因此需要加括号
b = np.random.normal(size=(3,2)) # 生成3行2列符合正态分布的随机数矩阵
c = np.random.randint(0,10,size=(3,2)) # 生成3行2列大小在0-10之间的整数随机数矩阵，参数中至少要给出下线数字
```
- 矩阵计算
`np.sum(a)` # 计算矩阵a的所有元素的总和

`np.min(a)` # 输出矩阵a的所有元素中最小的值

`np.max(a)` # 输出矩阵a的所有元素中最大的值

`np.sum(a,axis=0)`   # 对列求和，返回列数个元素成为一个一维矩阵

`np.sum(a,axis=1)`   # 对行求和，返回行数个元素成为一个一维矩阵

`np.argmin(a)` # 返回a矩阵中最小的元素的索引（注意索引是从0开始计算的）

`np.argmax(a)` # 返回a矩阵中最大的元素的索引

`np.mean(a)`   # 返回a矩阵所有元素的均值

`np.median(a)`   # 返回a矩阵所有元素的中位数，如果元素为偶数个，则返回中间两个数的均值

`np.sqrt(a)`   # 返回a矩阵所有元素的开方值

`np.sort(a)`   # 对矩阵a的每一行进行排序

`np.clip(a,2,7)`  # 矩阵a中的元素，小于2的会都变成2，大于7的会都大于7


### numpy的索引
矩阵的索引是从0开始，例如矩阵a
```
array([[ 2,  3,  4,  5],
       [ 6,  7,  8,  9],
       [10, 11, 12, 13]])
```

> a[0]  # 取的是整个第一行
> a[0][0]  # 取得的是2
> a[2][3]   # 值为13

- 可以用for循环遍历矩阵
```
>>> for i in b:      # 按行取
>>>     print i
...
[2 3 4 5]
[6 7 8 9]
[10 11 12 13]
```
```
>>> for i in b.T:    # 按列取，需要将矩阵转置
>>>     print i
...
[ 2  6 10]
[ 3  7 11]
[ 4  8 12]
[ 5  9 13]
```
```
>>> for i in b.flat:    # 遍历矩阵的每个元素，按行取每个元素
>>>     print i
...
2
3
4
5
6
7
8
9
10
11
12
13
```


### 矩阵的合并

**必须同一维度的矩阵才能合并**

- 竖直合并   #矩阵直接垂直堆叠成为新的矩阵
```
>>> a
array([[ 5,  2,  6],
       [17, 13, 10]])
>>> b
array([[13, 14, 14],
       [12, 11, 11]])
>>> c
array([[82, 80, 62],
       [91, 68, 60]])
>>> np.vstack((a,b,c))
array([[ 5,  2,  6],
       [17, 13, 10],
       [13, 14, 14],
       [12, 11, 11],
       [82, 80, 62],
       [91, 68, 60]])
```
- 水平合并   #参与合并的每个矩阵的同一行连接成一行，原始矩阵是几行合并完成的新矩阵还是几行
```
>>> np.hstack((a,b,c))
array([[ 5,  2,  6, 13, 14, 14, 82, 80, 62],
       [17, 13, 10, 12, 11, 11, 91, 68, 60]])
```

- concatenate  #可以指定参数，合并某一维度，合并即为

举例说明
```
>>> a = np.random.randint(10,50,size=(2,3,4))
>>> a
array([[[32, 36, 46, 36],
        [12, 13, 24, 34],
        [46, 17, 17, 31]],

       [[27, 28, 30, 41],
        [23, 35, 26, 30],
        [25, 35, 41, 24]]])
        
>>> b = np.random.randint(0,20,size=(2,3,4))
>>> b
array([[[ 8, 15, 11, 17],
        [12,  2, 13, 15],
        [15, 18,  0,  9]],

       [[10,  2, 14,  6],
        [ 7, 18,  5, 10],
        [16, 18, 14, 17]]])        

>>> np.concatenate((a,b),axis=0)
array([[[32, 36, 46, 36],
        [12, 13, 24, 34],
        [46, 17, 17, 31]],

       [[27, 28, 30, 41],
        [23, 35, 26, 30],
        [25, 35, 41, 24]],

       [[ 8, 15, 11, 17],
        [12,  2, 13, 15],
        [15, 18,  0,  9]],

       [[10,  2, 14,  6],
        [ 7, 18,  5, 10],
        [16, 18, 14, 17]]])
        
>>> np.concatenate((a,b),axis=1)
array([[[32, 36, 46, 36],
        [12, 13, 24, 34],
        [46, 17, 17, 31],
        [ 8, 15, 11, 17],
        [12,  2, 13, 15],
        [15, 18,  0,  9]],

       [[27, 28, 30, 41],
        [23, 35, 26, 30],
        [25, 35, 41, 24],
        [10,  2, 14,  6],
        [ 7, 18,  5, 10],
        [16, 18, 14, 17]]])     
```
**矩阵形状**
```
>>> a.shape
(2, 3, 4)
>>> b.shape
(2, 3, 4)
>>> c= np.concatenate((a,b),axis=0)
>>> c.shape
(4, 3, 4)
>>> c= np.concatenate((a,b),axis=1)
>>> c.shape
(2, 6, 4)
>>> c= np.concatenate((a,b),axis=2)
>>> c.shape
(2, 3, 8)
```
- 转置
   1. 矩阵.T == np.transpose(矩阵)
   2. atleast_2d  #2d是指维度为2,2也可以换成其他更大的数字X，即为将矩阵转换为X维度矩阵
```
>>> a = np.array([1,2,3])
c = np.atleast_2d(a)
>>> c
array([[1, 2, 3]])
```

### 矩阵的分割

- np.split(被分割矩阵，分割后的矩阵数目，axis=数字)  # 等分分割，分割后的矩阵形状相同
- np.array_split(被分割矩阵，分割后的矩阵数目，axis=数字)  # 可以进行不等分分割,例如将4列分为3份，则第一份是2，后两份都是1；5列分为3份，则第1、2份是2，最后一份是1；

```
>>> a
array([[84,  4, 22, 79],
       [30, 23,  3, 61],
       [ 5, 77,  0, 40]])
       
>>> b,c,d =np.split(a,3,axis=0)
>>> b
array([[84,  4, 22, 79]])
>>> c
array([[30, 23,  3, 61]])
>>> d
array([[ 5, 77,  0, 40]])       
```
```
>>> x = np.random.randint(0,100,size=(3,5))
>>> x
array([[66,  4, 64, 48,  8],
       [39, 28, 51, 40, 94],
       [38, 58, 51, 85, 96]])
>>> b,c,d = np.array_split(x,3,axis=1)
>>>
>>> b
array([[66,  4],
       [39, 28],
       [38, 58]])
>>>
>>> c
array([[64, 48],
       [51, 40],
       [51, 85]])
>>>
>>> d
array([[ 8],
       [94],
       [96]])
```

### numpy的浅拷贝和深拷贝

- 浅拷贝 # 两个指针指向同一块存储，改一个另外一个会跟着改
```
>>> a = np.array([1,2,3])
>>> b=a
>>> b
array([1, 2, 3])
>>> b[0]=10
>>> b
array([10,  2,  3])
>>> a
array([10,  2,  3])

>>> c = a[::]
>>> c
array([10,  2,  3])
>>> c[0] = 50
>>> c
array([50,  2,  3])
>>> a
array([50,  2,  3])
```

- 深拷贝 # 两个不同的存储，是两个独立的数据，改一个的时候，另一个不会跟着改
```
>>> d = np.copy(a
>>> d
array([50,  2,  3])
>>> d[0]=100
>>> d
array([100,   2,   3])
>>> a
array([50,  2,  3])
```



## pandas


# 参考

[B站课程——AI_MOOC]（https://www.bilibili.com/video/av38355831/?p=6）
